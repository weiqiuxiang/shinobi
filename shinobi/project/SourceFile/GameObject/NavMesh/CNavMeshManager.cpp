#include "CNavMeshManager.h"
#include "CPolygonMath.h"
#include "CModelStorage.h"
#include "CMeshFieldManager.h"

CNavMeshManager::CNavMeshManager()
{
	m_PlayerPositionInMeshNumber = -1;
}

CNavMeshManager::~CNavMeshManager() 
{
	
}

void CNavMeshManager:: UpdateAll(void)
{
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		m_NavMeshArray[i].Update();
	}
}

void CNavMeshManager::DrawAllNavMeshAndConnect(void)
{
	//ナビメッシュの描画
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		if (m_NavMeshArray[i].GetIsUse() == false) {
			continue;
		}
		
		m_NavMeshArray[i].DrawInEditor();
	}

	//繋がりの描画

}

void CNavMeshManager::UninitAll(void)
{
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		m_NavMeshArray[i].Uninit();
	}
}

CNavMesh* CNavMeshManager::GetPointer(int NavMeshID)
{
	bool IsOverRange = NavMeshID < 0 || NavMeshID >= NAVMESH_MAX_NUM;
	if (IsOverRange) {
		_RPT0(0, "[CNavMeshManager.cpp][GetPointer]引数NavMeshIDの値は範囲外\n");
		return nullptr;
	}

	return &m_NavMeshArray[NavMeshID];
}

void CNavMeshManager::SetAllNavMeshNoCheck(void)
{
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		m_NavMeshArray[i].SetState(NAVMESH_NO_CHECK);
	}
}

void CNavMeshManager::NoUseAllNavMesh(void)
{
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		m_NavMeshArray[i].SetIsUse(false);
	}
}

int CNavMeshManager::CalcPlayerInMeshNumber(const D3DXVECTOR3& PlayerPosition)
{
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		if (m_NavMeshArray[i].GetIsUse() == false) {
			continue;
		}

		D3DXVECTOR3 LeftTopPos = m_NavMeshArray[i].GetLeftTopVertexPosition();
		D3DXVECTOR3 RightBottomPos = m_NavMeshArray[i].GetRightBottomVertexPosition();

		bool HitX = PlayerPosition.x >= LeftTopPos.x && PlayerPosition.x <= RightBottomPos.x;
		bool HitZ = PlayerPosition.z >= LeftTopPos.z && PlayerPosition.z <= RightBottomPos.z;

		if(HitX && HitZ){
			m_PlayerPositionInMeshNumber = i;
			return m_PlayerPositionInMeshNumber;
		}
	}

	return -1;
}

//配置したオブジェクトのAABBと当り判定をし、自動ナビメッシュを生成する
//引数説明:
//MasuNum : マス数,MasuNum.xはX軸方向のマス数,MasuNum.yはZ軸方向のマス数
//size : ナビメッシュのサイズ
//Dist : ナビメッシュの間隔,Dist.xはX軸方向の間隔,Dist.yはZ軸方向の間隔
void CNavMeshManager::AutoGeneratedNavMesh(const D3DXVECTOR2& MasuNum, const D3DXVECTOR3& size, const D3DXVECTOR2& Dist)
{
	const int XAxisNum = abs((int)MasuNum.x);
	const int ZAxisNum = abs((int)MasuNum.y);
	const float TotalWidth = XAxisNum * size.x + (XAxisNum - 1) * Dist.x;
	const float TotalHeight = ZAxisNum * size.y + (ZAxisNum - 1) * Dist.y;

	const D3DXVECTOR3 LeftTopPosition = D3DXVECTOR3(-TotalWidth * 0.5f, 0.0f, -TotalHeight * 0.5f);		//左上座標

	//数XAxisNum * ZAxisNumを生成する
	for (int Z = 0; Z < ZAxisNum; Z++) {
		for (int X = 0; X < XAxisNum; X++) {
			D3DXVECTOR3 MeshPosition;
			MeshPosition.y = 0.0f;
			MeshPosition.x = LeftTopPosition.x + X * (size.x + Dist.x);
			MeshPosition.z = LeftTopPosition.z + Z * (size.y + Dist.y);
			MeshPosition.y = CMeshFieldManager::CalcPosYValueInMeshField(MeshPosition) + 1.0f;

			//メッシュ生成
			CreateNewNavMesh(MeshPosition, size, true);
		}
	}

	//AABBと当り判定存在するメッシュの歩けるフラグをfalseにする
	for (int NavMeshNum = 0; NavMeshNum < NAVMESH_MAX_NUM; NavMeshNum++) {
		if (m_NavMeshArray[NavMeshNum].GetIsUse() == false) {
			continue;
		}

		D3DXVECTOR3 CenterPos = m_NavMeshArray[NavMeshNum].GetCenterPosition();
		D3DXVECTOR2 MeshPos = D3DXVECTOR2(CenterPos.x, CenterPos.z);
		D3DXVECTOR2 HitSize = D3DXVECTOR2(size.x, size.y);

		//全てのモデルとのAABBの当り判定を取る
		for (int ModelNum = 0; ModelNum < MODEL_OBJ_MAX; ModelNum++) {
			//モデルポインタ取得
			CModel* pModel = CModelStorage::GetObj(ModelNum);
			if (pModel == nullptr) {
				continue;
			}

			//AABBの情報取得
			D3DXVECTOR2 ModelPos = D3DXVECTOR2(pModel->GetPosition().x, pModel->GetPosition().z);
			D3DXVECTOR2 XValue, YValue, ZValue;
			pModel->GetAABBValue(&XValue, &YValue, &ZValue);
			D3DXVECTOR2 AABBSize = D3DXVECTOR2(fabs(XValue.y - XValue.x), fabs(ZValue.y - ZValue.x));

			bool IsHit = CPolygonMath::HitAABB2D(MeshPos, HitSize, ModelPos, AABBSize);

			//当り判定があったら
			if (IsHit == true) {
				m_NavMeshArray[NavMeshNum].SetIsCanWalk(false);
				break;
			}
		}
	}

	//ナビメッシュの繋がり
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		if (m_NavMeshArray[i].GetIsUse() == false) {
			continue;
		}

		//一行しかいない場合、処理しない
		if (XAxisNum <= 1 || ZAxisNum <= 1) {
			break;
		}

		//ナビメッシュ
		bool IsTop = (i / XAxisNum) == 0;
		bool IsBottom = (i / XAxisNum) == ZAxisNum - 1;

		//上端にあるか
		if (IsTop == true) {
			bool IsLeftSign = (i % XAxisNum) == 0;
			bool IsRightSign = (i % XAxisNum) == XAxisNum - 1;
			//左端
			if (IsLeftSign == true) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum + 1]);
			}
			//右端
			if (IsRightSign == true) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum - 1]);
			}
			//中間
			if ((!IsLeftSign) && (!IsRightSign)) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum + 1]);
			}
			continue;
		}

		//下端にあるか
		if (IsBottom == true) {
			bool IsLeftSign = (i % XAxisNum) == 0;
			bool IsRightSign = (i % XAxisNum) == XAxisNum - 1;
			//左端
			if (IsLeftSign == true) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum + 1]);
			}
			//右端
			if (IsRightSign == true) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum - 1]);
			}
			//中間
			if ((!IsLeftSign) && (!IsRightSign)) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum + 1]);
			}
			continue;
		}

		//中間にあるか
		if ((!IsTop) && (!IsBottom)) {
			bool IsLeftSign = (i % XAxisNum) == 0;
			bool IsRightSign = (i % XAxisNum) == XAxisNum - 1;

			//左端
			if (IsLeftSign == true) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum ]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum + 1]);
			}
			//右端
			if (IsRightSign == true) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum - 1]);
			}
			//中間
			if ((!IsLeftSign) && (!IsRightSign)) {
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i - XAxisNum + 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum - 1]);
				m_NavMeshArray[i].AddConnectDoubleDir(&m_NavMeshArray[i + XAxisNum + 1]);
			}
			continue;
		}
	}
}

CNavMesh* CNavMeshManager::CreateNewNavMesh(const D3DXVECTOR3& pos, const D3DXVECTOR3& size, bool CanWalkFlag)
{
	for (int i = 0; i < NAVMESH_MAX_NUM; i++) {
		if (m_NavMeshArray[i].GetIsUse() == false) {
			m_NavMeshArray[i].Init(pos, size, CanWalkFlag,true);
			return &m_NavMeshArray[i];
		}
	}

	_RPT0(0,"[CNavMeshManager.cpp][CreateNewNavMesh]m_NavMeshArrayの要素数は上限に達した\n");
	return nullptr;
}

